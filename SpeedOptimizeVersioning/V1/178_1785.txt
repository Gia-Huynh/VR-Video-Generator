Worker begin from  1785  to  1795
video_length:  318395 , begin and end:  1785 1795
Writing file  1794 with length (in frames):  10
 90.0 %, Time elapsed (minutes): 0.18753705819447836 , ETA: 0.020837450910497594 , Estimated Total Time (minutes): 0.20837450910497596
ffmpeg pipe write time:  0.27900004386901855
Worker ending
Timer unit: 1e-07 s

Total time: 11.1843 s
File: L:\JAV Segmentation 2025\PredictAndGenerate.py
Function: left_side_sbs at line 108

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   108                                           def left_side_sbs(raw_img, inference_queue, result_queue):
   109                                               #Reuse old depth if frame is not much different shenanigan.
   110                                               global last_depth_flag
   111                                               global last_frame
   112                                               global last_depth
   113                                               #Used to be  (np.sum (cv2.absdiff (cv2.stackBlur(raw_img, (5, 5)), cv2.stackBlur(last_frame, (3, 3)))) < 6000000)
   114        10    1356351.0 135635.1      1.2      if (last_frame is not None) and (np.sum (cv2.absdiff (cv2.stackBlur(raw_img, (3, 3)), cv2.stackBlur(last_frame, (3, 3)))) < 2000000) and (last_depth_flag == True):
   115                                                   depth = last_depth
   116                                               else:     
   117        10     672411.0  67241.1      0.6          last_frame = raw_img.copy()
   118        10      12454.0   1245.4      0.0          inference_queue.put((raw_img,)) #Khong can stackblur raw_img vi img cung bi resize ve 518 default cua DepthAnything
   119        10   59660773.0    6e+06     53.3          depth = result_queue.get()
   120        10        178.0     17.8      0.0          if (last_depth_flag == False):
   121         5     317909.0  63581.8      0.3              depth = depth*0.6 + last_depth*0.4
   122         5      62075.0  12415.0      0.1              last_depth = depth.copy()
   123         5         44.0      8.8      0.0              last_depth_flag = True
   124                                                   else:
   125         5         28.0      5.6      0.0              last_depth_flag = False
   126         5      61932.0  12386.4      0.1              last_depth = depth.copy()
   127                                           
   128                                               #Normal image fill
   129        10       1294.0    129.4      0.0      result_blank_mask = np.zeros(raw_img.shape[:2], dtype=bool)
   130        10        584.0     58.4      0.0      result_img = np.zeros(raw_img.shape, dtype=raw_img.dtype)
   131                                               #Edge blurring DOES NOT CONSUME CPU TIME MUCH.
   132        10        529.0     52.9      0.0      edge_fill_blank_mask = np.zeros(raw_img.shape[:2], dtype=bool)
   133        10      19097.0   1909.7      0.0      limit_step = math.ceil(depth.max())
   134        10        311.0     31.1      0.0      offset_range = [offset_bg * raw_img.shape[0], offset_fg * raw_img.shape[0] * limit_step/14.0]
   135        10         39.0      3.9      0.0      max_depth = limit_step
   136        10        223.0     22.3      0.0      kernel_size = round(0.0047 * raw_img.shape[0]) #0.0047 is the OG, then 0.0036 works fine, 0.0024 is a bit too low.
   137        10       1835.0    183.5      0.0      kernel_expand = np.ones ((max(kernel_size, 1),  max(kernel_size, 1)))
   138                                               #Threshold values
   139        10    3319331.0 331933.1      3.0      cu = sorted(get_cutoff(depth, last_depth))
   140        10        819.0     81.9      0.0      nt = [cu[i+1]-cu[i] for i in range(len(cu)-1)]
   141        10         83.0      8.3      0.0      cu.pop() #Remove last element
   142                                               
   143        70       1951.0     27.9      0.0      for i, curr_step in zip(cu, nt):
   144        60    2159249.0  35987.5      1.9          bin_mask = (((i - 0.05 * curr_step) <= depth) & (depth < i + 1.05 * curr_step)).astype(bool)
   145                                           
   146        60   10133706.0 168895.1      9.1          bin_mask_expanded = np.repeat(bin_mask[:, :, None], 3, axis=2)
   147        60     535999.0   8933.3      0.5          masked_img = np.zeros_like(raw_img)
   148        60   18465180.0 307753.0     16.5          masked_img[bin_mask_expanded] = raw_img[bin_mask_expanded]
   149                                           
   150        60      40287.0    671.5      0.0          masked_mask = np.zeros(raw_img.shape[:2], dtype=bool)
   151        60     281778.0   4696.3      0.3          masked_mask[bin_mask] = True
   152                                                   
   153        60       4956.0     82.6      0.0          offset_x = int((i+0.5*curr_step) / (0.00001+limit_step - curr_step) * (0.00001+offset_range[1] - offset_range[0]) + offset_range[0])
   154        60        441.0      7.3      0.0          if offset_x != 0:
   155                                                       #Room for Optimization: np.roll
   156                                                       #https://gist.github.com/cchwala/dea03fb55d9a50660bd52e00f5691db5
   157        60     719659.0  11994.3      0.6              masked_img = np.roll(masked_img, shift=offset_x, axis=1)  # Shift along the width (x-axis)
   158        60     472609.0   7876.8      0.4              masked_mask = np.roll(masked_mask, shift=offset_x, axis=1).astype (np.bool)
   159                                           
   160                                                   #This one is for edge filling for "close-by" objects
   161        60        438.0      7.3      0.0          if (offset_x > 0):
   162        30    1665163.0  55505.4      1.5             edge_fill_blank_mask |= cv2.filter2D(masked_mask.astype(np.int16), -1, np.array([[1, -2, 1]], dtype=np.int16))>0
   163                                                   #mask_nonzero = masked_mask
   164        60    8840979.0 147349.6      7.9          result_img[masked_mask] = masked_img[masked_mask]
   165        60      95252.0   1587.5      0.1          result_blank_mask |= masked_mask
   166                                           
   167        10      26610.0   2661.0      0.0      result_zero_mask = ~result_blank_mask  # inverted boolean mask where no pixel was filled
   168        10     173866.0  17386.6      0.2      result_zero_mask = cv2.morphologyEx(result_zero_mask.astype(np.uint8), cv2.MORPH_CLOSE, kernel_expand) #BETTER
   169                                               #Fill result_img with blurred value from zero_mask
   170        10     109582.0  10958.2      0.1      result_zero_mask = result_zero_mask.astype(bool)
   171        30    1517197.0  50573.2      1.4      result_img[result_zero_mask] = (cv2.stackBlur
   172        20     110988.0   5549.4      0.1                                      (np.roll
   173        10        328.0     32.8      0.0                                       (raw_img, shift=round(offset_x/3), axis=1)
   174        10        221.0     22.1      0.0                                      ,(limit_step*2 + 3, round(limit_step/8)*2 + 1)
   175                                                                               )
   176        10         64.0      6.4      0.0                                     )[result_zero_mask]
   177                                               #Is this line necessary?
   178                                               #edge_fill_blank_mask = cv2.dilate(edge_fill_blank_mask.view(np.uint8), np.ones((1, 3)), iterations = 1).astype(bool)
   179                                           
   180        10     601403.0  60140.3      0.5      result_img[edge_fill_blank_mask] = cv2.stackBlur (result_img, (kernel_size+(kernel_size%2==0), kernel_size+(kernel_size%2==0)))[edge_fill_blank_mask]
   181                                           
   182        10      11522.0   1152.2      0.0      result_img[:, 0:round(offset_x/3), :] = raw_img[:, 0:round(offset_x/3), :]
   183        10         78.0      7.8      0.0      if last_frame is not None:
   184        10     385170.0  38517.0      0.3          return cv2.hconcat([result_img, last_frame])
   185                                               else:
   186                                                   return cv2.hconcat([result_img, raw_img])

Total time: 0.32633 s
File: L:\JAV Segmentation 2025\SupportFunction.py
Function: get_cutoff at line 86

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    86                                           def get_cutoff (depth_img, last_depth):
    87                                               #Getting cutoff locations from depth_img    
    88                                               #DO NOT FUCKING MODIFY THIS FUNCTION, WE HAVE TESTED IT A LOT IN THE PAST AND FUCKING LEAVE IT BE
    89        10        141.0     14.1      0.0      step_width = 0.125
    90        10      13543.0   1354.3      0.4      bin_range = np.arange(0, depth_img.max(), step_width)
    91        10    1733762.0 173376.2     53.1      profile_temp_var = np.digitize (depth_img, bin_range)
    92        10    1206775.0 120677.5     37.0      a, bin_count = np.unique(profile_temp_var, return_counts = True)
    93        10        385.0     38.5      0.0      bin_count_avg = np.zeros (bin_count.shape)
    94                                           
    95      1120       2394.0      2.1      0.1      for j in range (1, len(bin_count)-1):
    96      1110      45701.0     41.2      1.4          bin_count_avg [j] = 0.33 * bin_count[j] + 0.33 * bin_count[j-1] + 0.33 * bin_count[j+1]
    97        10        295.0     29.5      0.0      bin_count_avg [0] = 0.5 * bin_count[0] + 0.5 * bin_count[j+1]
    98        10        342.0     34.2      0.0      bin_count_avg [len(bin_count)-1] = 0.5 * bin_count[len(bin_count)-1] + 0.5 * bin_count[len(bin_count)-2]
    99        10         44.0      4.4      0.0      bin_count = bin_count_avg
   100                                               
   101        10        389.0     38.9      0.0      bin_label = bin_range[a-1]
   102                                               
   103        10         48.0      4.8      0.0      Result_Cutoff_List = []
   104        10         32.0      3.2      0.0      Max = -1
   105        10         32.0      3.2      0.0      MaxIdx = -1
   106        10         71.0      7.1      0.0      assert (len(bin_label) == len(bin_count))
   107      1120       2705.0      2.4      0.1      for i in range (1, len(bin_label)-1):
   108      1110       3253.0      2.9      0.1          label = bin_label[i+1]
   109      1110       2772.0      2.5      0.1          count = bin_count[i]
   110      1110       2630.0      2.4      0.1          if (Max == -1):
   111        10         42.0      4.2      0.0              Max = count
   112        10         22.0      2.2      0.0              MaxIdx = i
   113                                                   else:
   114      1100       2315.0      2.1      0.1              if (Max < count):
   115       407        769.0      1.9      0.0                  Max = count
   116       407        709.0      1.7      0.0                  MaxIdx = i
   117                                                       else:
   118                                           UnicodeEncodeError - help wanted for a fix
   119       693       4514.0      6.5      0.1                      ((count *(1 - 0.0125*(Max/count)) < bin_count[i+1] * 0.96) 
   120        91        600.0      6.6      0.0                           and (count *(1 - 0.0125*(Max/count)) < bin_count[i-1] * 0.99)
   121        61        531.0      8.7      0.0                        and (i - MaxIdx >= round(0.5/step_width - 1)))
   122                                           UnicodeEncodeError - help wanted for a fix
   123       644       4687.0      7.3      0.1                      or ((count *(1.01 - 0.01*(Max/count)) < bin_count[i+1] * 0.93)
   124        18        114.0      6.3      0.0                           and (count *(1.01 - 0.01*(Max/count)) < bin_count[i-1] * 0.8)
   125                                                                    )
   126                                                               ):
   127        49        231.0      4.7      0.0                      Result_Cutoff_List.append (label)
   128        49        105.0      2.1      0.0                      Max = count
   129        49         92.0      1.9      0.0                      MaxIdx = i
   130                                           
   131                                               #Result_Cutoff_List = sorted (Result_Cutoff_List)
   132        10      51450.0   5145.0      1.6      Result_Cutoff_List.append(depth_img.max())
   133        10        745.0     74.5      0.0      Result_Cutoff_List.insert (0, 0)
   134        10        321.0     32.1      0.0      Result_Cutoff_List = sorted (Result_Cutoff_List)
   135                                               
   136        59        274.0      4.6      0.0      for i in range (len(Result_Cutoff_List)-2, 0, -1):
   137        49        434.0      8.9      0.0          if abs(Result_Cutoff_List[i] - Result_Cutoff_List[i+1])<1:
   138         7         37.0      5.3      0.0              del Result_Cutoff_List[i]
   139                                               global last_cutoff
   140        10         48.0      4.8      0.0      if (last_cutoff is not None):
   141         9     179796.0  19977.3      5.5          if (np.linalg.norm(depth_img - last_depth) < 500):
   142         9        120.0     13.3      0.0              if (len(last_cutoff) >= len(Result_Cutoff_List)):
   143         9         25.0      2.8      0.0                  return last_cutoff
   144                                                       else:
   145                                                           pass
   146                                                   else:
   147                                                       pass
   148                                                       #print ("Norm Declined: ", np.linalg.norm(depth_img - last_depth))
   149         1          6.0      6.0      0.0      last_cutoff = Result_Cutoff_List
   150         1          2.0      2.0      0.0      return Result_Cutoff_List

